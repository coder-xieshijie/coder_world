![Java线程无限创建](https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/2024/Java线程无限创建_c63c2a37780bfbaeb19bf50b388b4ca3.jpg)

> 哈喽，大家好🎉，我是世杰。
>
> ⏩本次给大家介绍一下操作系统线程和Java的线程以及二者的关联



## 1. 面试连环call

1. 💻Java线程可以**无限创建**吗?
1. 💻Java线程和**操作系统线程**有什么关联?
1. 💻操作系统为什么要区分**内核态和用户态**?

⏩要想解答这些问题，我们要先从操作系统线程开始说起，让我们开始吧🎉🎉🎉



---



## 2. 操作系统线程



### 2.1 内核态和用户态

根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：

- **用户态**(User Mode) : 用户态运行的进程可以直接读取用户程序的数据，拥有**较低的权限**。

- **内核态**(Kernel Mode)：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，**拥有非常高的权限**。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。

  

![usermode-and-kernelmode](https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/2024/usermode-and-kernelmode_9fb77ff97c8c1f3ad538bddd1688b01a-20240706163628316_3a9fc8b4d0f76c718be6132c8e856e90.jpeg)



>那为什么要区分用户态和内核态呢？

- 在 CPU 的所有指令中，有一些指令是**比较危险**的比如**内存分配**、**设置时钟**、**IO 处理**等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 **特权指令** 。

- 如果计算机系统中只有一个内核态，那么所有程序或进程都必须**共享系统资源**，例如内存、CPU、硬盘等，这将导致**系统资源的竞争和冲突**，从而影响系统性能和效率。并且，这样也会让系统的**安全性降低**，毕竟所有程序或进程都具有相同的特权级别和访问权限。



### 2.2 用户态线程

在**早期**的操作系统中，所有的**线程都是在用户态**下实现，操作系统只能调度线程所属的进程，而**无法调度线程**。

在这种模型下，用户需要**自己定义线程**的数据结构、创建、销毁、调度和维护等，这些线程运行在某个进程内，**操作系统直接对进程进行调度**。

![img](https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/2024/20210418213806-20230110113729888_2cf988dac7ffedf10b1ab4cdfedc2645.png)

**『优点』**：
- 即使操作系统原生不支持线程，我们也可以**通过库函数来支持线程**
- 线程的调度只发生在用户态，避免了操作系统**从内核态到用户态的转换**开销。

**『缺点』**：
- 由于操作系统无法调度线程，CPU 的时间片切换是**以进程为维度**的，如果进程中某个**线程进行了耗时比较长的操作**，那么由于用户态中**没有时钟中断机制**，就会导致此进程中的其它线程因为得不到 CPU 资源而长时间的持续等待；
- 如果某个线程进行系统调用时比如**缺页中断而导致了线程阻塞**，此时操作系统也会**阻塞整个进程**，即使这个进程中其它线程还在工作。





### 2.3 内核态线程

**现代**操作系统，包括 **Windows、Linux、Mac OS X 和 Solaris** 等，都支持内核线程。线程**运行在内核空间**，直接由内核负责，由内核来完成调度。

此时我们可以直接使用操作系统中已经**内置好的线程**，线程的创建、销毁、调度和维护等，都直接由**操作系统的内核**来实现，我们只需要使用**系统调用**就好了，不需要像用户级线程那样自己设计线程调度。

![img](https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/2024/20210418214229_ae3b3fcb401c25cc289b90414a31a591-20240706163628304_0bf52f56e8aba894a938760e9f5097f4.png)

**内核线程和用户线程的对应关系**并不完全是1对1，其关联模式有三种



### 2.4 线程模型




> **多对一线程模型**：



**多个用户线程对应到同一个内核线程**上，线程的创建、调度、同步的所有细节全部由进程的用户空间线程库来处理。这样，极大地**减少了创建内核态线程的成本**，但是线程不可以并行。因此，这种模型现在基本上用的很少。

![img](https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/2024/1435569-20210101100744821-662751768_31666b37c6e600bff4cfdaa1763bd4b3-20240706163628390_b665aa2fa02c080af8f840ba982aa693.png)

**『优点』**：

- 用户线程的很多操作对内核来说都是**透明**的，不需要用户态和内核态的**频繁切换**。使线程的创建、调度、同步等非常快。

**『缺点』**：

- 由于多个用户线程对应到同一个内核线程，如果其中一个**用户线程阻塞，那么该其他用户线程也无法执行**。
- 内核并不知道用户态有哪些线程，无法像内核线程一样实现较完整的**优先级调度**等操作



> **一对一线程模型**：



该模型为**每个用户态的线程分配一个单独的内核态线程**，在这种情况下，每个用户态都需要通过系统调用创建一个绑定的内核线程。 这种模型允许所有线程**并行执行**，能够充分利用多核优势。目前 **Linux 中的线程**、**OpenJDK Java 线程**等采用的都是一对一线程模型。每一个JVM线程，都有一个对应的内核线程。

![img](https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/2024/1435569-20210101100809480-2111181521_1d3962a2589a6799d8791dc08d5d7957-20240706163628342_c85183292514fc52ddc960f34f9eea57.png)

**『优点』**：

- 解决了多对一模型的**阻塞**和**调度**问题
- 实现起来较为简单

**『缺点』**：

- 每创建一个用户线程，相应地就需要创建一个内核线程，**开销较大，因此需要限制整个系统的线程数量**。
- 对用户线程的大部分操作都会映射到内核线程上，**引起用户态和内核态的频繁切换**。



> **多对多线程模型**：



这种模式下会为 n 个用户态线程分配 m 个内核态线程。**m 通常小于 n**。一种可行的策略是将 **m 设置为核数**。这种多对多的关系，减少了内核线程，同时也保证了多核心并行。多对多模型中**线程的调度需要由内核态和用户态一起来实现**，例如线程间同步需要用户态和内核态共同实现。用户态和内核态的分工合作导致实现该模型非常复杂。

PS: **Linux多线程模**型曾经也想使用该模型，但它太复杂，要对内核进行大范围改动，所以还是**采用了一对一的模型**！



![img](https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/2024/1435569-20211212155406006-1044954047_2c6536dbcdba2701730e21351b0786a0-20240706163628337_1598316d44c49826097ab6105e4ea1c8.png)



**『优点』**：

*   多对多模型将任意数量的用户线程复用到相同或更少数量的内核线程上，**结合了一对一和多对一模型的最佳特性**
*   用户对创建的线程数**没有限制**

**『缺点』**：

- 实现起来**非常复杂**









-----







## 3. Java 线程



### 3.1 线程库

在进入 Java 线程主题之前，有必要讲解一下**线程库** Thread library 的概念。

**线程库就是为开发人员提供创建和管理线程的一套 API**。线程库不仅可以在用户空间中实现，还可以在内核空间中实现。前者涉及仅在用户空间内实现的 API 函数，没有内核支持。后者涉及系统调用，也就是说调用库中的一个 API 函数将会导致对内核的系统调用，并且需要具有线程库支持的内核。

> 下面简单介绍下三个主要的线程库：

- **POSIX线程**：是[POSIX]的[线程]标准，定义了创建和操纵线程的一套[API]。实现POSIX线程标准的库常被称作**pthreads**，一般用于[Unix-like] POSIX系统，如[Linux]、 [Solaris]。

- **Win32 线程**：用于 **Window 操作系统**的内核级线程库

- Java 线程：**Java 线程 API 通常采用宿主系统的线程库来实现**，也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现，在 UNIX 类系统上，采用 Pthread 来实现。



### 3.1 Java线程模型

-  **在 JDK 1.2 之前**，Java 线程是基于称为 "绿色线程"（Green Threads）的用户级线程实现的，JVM 开发了自己的一套线程库或者说线程管理机制。

- **在 JDK 1.2 及以后**，JVM 选择了更加稳定且方便使用的操作系统原生的内核级线程，通过系统调用，将线程的调度交给了操作系统内核。而对于不同的操作系统来说，它们本身的设计思路基本上是完全不一样的，因此它们各自对于线程的设计也存在种种差异，所以 JVM 中明确声明了：**虚拟机中的线程状态，不反应任何操作系统中的线程状态**。

因此，现今 Java 中线程的本质，其实就是**操作系统中的线程**，其线程库和线程模型很大程度上依赖于**操作系统（宿主系统）的具体实现**，比如在 Windows 中 Java 就是基于 Wind32 线程库来管理线程，且 Windows 采用的是**一对一的线程模型**。



### 3.2 Java线程创建数量

每个线程都有一个线程栈空间**通过-Xss设置**，可以通过JVM配置，JVM的默认栈大小

![img](https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/2024/fojx15t85g_b1b6f2325a68ae2db4b8fbbe0f9e9bd0-20240706163628359_f381827c618616ce7d1fe85a1b39f0dd.png)

不考虑系统限制，可以通过如下公式计算，得出最大线程数量



> 线程数量=（机器本身可用内存-JVM分配的堆内存）/Xss的值



**根据计算公式，得出如下结论：**

- **结论1**：JVM堆越大，系统创建的线程数量越小。

- **结论2**：当-Xss的值越小，可生成线程数量越多。

假如我们的容器内存大小是8G,堆大小是4096M，走-Xss默认值，可以得出 最大线程数量：4096个。



我们知道操作系统分配给每个进程的内存大小是有限制的，比如32位的Windows是2G。因此操作系统对一个进程下的线程数量是有限制的，不能无限的增多。



如果考虑系统限制，主要跟以下几个参数有关系

- **/proc/sys/kernel/pid_max** 增大，线程数量增大，pid_max有最高值，超过之后不再改变，而且32，64位也不一样

- **/proc/sys/kernel/thread-max** 系统可以生成最大线程数量

线程是非常宝贵的资源，我们要严格控制线程的数量



---



**『引用』：**

[Threads](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)

[Java 线程和操作系统的线程有啥区别？](https://www.cnblogs.com/cswiki/p/14676264.html)

[一台 Java 服务器可以跑多少个线程？](https://cloud.tencent.com/developer/article/1532096)

[操作系统常见面试题总结(上)](https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html)

[用户态线程和内核态线程的区别](https://cloud.tencent.com/developer/article/1532096)