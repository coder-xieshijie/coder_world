

滴滴日常实习一面问题及解析



> 正文



最近看了牛客网同学关于滴滴日常实习的面经

笔者尝试以面试官的角度对问题进行分析，并给出自己理解的答案



## 面试题



1. 目前使用的JDK版本是哪个？
2. 并发编程哪个类使用的比较多？场景是什么？
3. CountDownLatch底层原理？
4. AQS底层原理？
5. AQS公平锁和非公平锁？
6. AQS使用CAS去修改status属性，修改失败，会自旋吗？
7. 如果不用CountDownLatch，还可以用什么方案？
8. CMS和G1垃圾回收器？
9. 看过什么源码？讲一讲SpringBoot自动配置原理？
10. 垂直分库，有没有跨数据库查询？
11. 项目中是如何实现使用Redis作为缓存的？
12. 项目并发量如何？



## 解析答案

### 1. 目前使用的JDK版本是哪个？

「**考察要点**」

- 对JDK版本特性的熟悉程度。
- 是否跟进JDK的新版本及其改进。

「**回答**」

目前公司项目主要使用的是JDK 8版本。虽然JDK 11及其后续版本已经发布，但JDK 8在稳定性和社区支持方面仍然是许多公司首选。同时，JDK 8提供的Lambda表达式和Stream API大大简化了并发和集合操作。此外，我们也在对一些新项目进行JDK 11的评估和试用，以便在未来平滑过渡。

### 2. 并发编程哪个类使用的比较多？场景是什么？

「**考察要点**」

- 对并发编程的理解和实践经验。
- 实际应用场景的处理能力。

「**回答**」

在并发编程中，使用最多的是`java.util.concurrent`包下的`ThreadPoolExecutor`和`CompletableFuture`类。`ThreadPoolExecutor`用于管理线程池，提高资源利用率和性能，常用于需要执行大量并发任务的场景，如批量处理数据和并发请求处理。`CompletableFuture`则简化了异步编程，常用于异步任务链的构建和组合，如并行调用多个API并处理结果。

### 3. CountDownLatch底层原理？

「**考察要点**」

- 对并发工具的理解。

- 能否解释底层实现。

「**回答**」

`CountDownLatch`通过一个计数器来实现线程同步。其底层原理是通过`AQS`（AbstractQueuedSynchronizer）来实现的。每次调用`countDown()`方法时，计数器减一，当计数器减至零时，所有在`await()`方法上等待的线程被唤醒，继续执行后续逻辑。`AQS`通过状态（state）变量和内部FIFO等待队列管理线程的同步与阻塞。

### 4. AQS底层原理？

「**考察要点**」

- 对Java并发包核心类的理解。

- 能否解释复杂的底层实现。

「**回答**」

`AQS`（AbstractQueuedSynchronizer）是一个用于构建锁和其他同步器的框架。其底层原理是通过一个状态变量（state）和一个FIFO等待队列来实现线程的同步。状态变量通过CAS（Compare-And-Swap）原子操作进行修改，确保线程安全。线程尝试获取锁失败时，会被包装成Node节点加入到等待队列中，直到被唤醒。`AQS`还支持独占模式和共享模式两种锁机制。

### 5. AQS公平锁和非公平锁？

「**考察要点**」

- 对锁机制的理解。

- 公平锁和非公平锁的区别和应用场景。

「**回答**」

`AQS`的公平锁（Fair Lock）和非公平锁（Unfair Lock）主要区别在于获取锁的策略。公平锁按照请求锁的顺序来分配锁，先来先得，防止线程饥饿。而非公平锁则不保证顺序，在锁释放时，任何等待线程都有机会获取锁，可能会导致某些线程长期得不到锁。公平锁通过`ReentrantLock`的构造函数`new ReentrantLock(true)`实现，非公平锁则是`new ReentrantLock(false)`实现。

### 6. AQS使用CAS去修改status属性，修改失败，会自旋吗？

「**考察要点**」

- 对CAS机制的理解。

- 对自旋锁的理解。

「**回答**」

是的，当`AQS`使用CAS（Compare-And-Swap）去修改status属性失败时，会进行自旋。自旋的目的是在多核CPU环境下，通过反复尝试，减少线程切换带来的开销。自旋通常会有一个次数限制，超过限制后，线程会进入阻塞状态，加入等待队列，直到被唤醒。

### 7. 如果不用CountDownLatch，还可以用什么方案？

「**考察要点**」

- 对多种并发工具的理解和应用能力。

- 提供替代方案的能力。

「**回答**」

如果不用`CountDownLatch`，还可以使用以下方案：

- `CyclicBarrier`：适用于一组固**定数量的线程**之间的同步，所有线程都到达屏障点后才会继续执行。
- `Semaphore`：通过许可机制控制多个线程的并发访问。
- `Phaser`：支持多阶段的任务同步，更加灵活，适用于动态变化的线程数量。
- `CompletableFuture`：用于处理**异步任务**，可以组合多个异步操作，简化并发编程。

### 8. CMS和G1垃圾回收器？

「**考察要点**」

- 对不同垃圾回收器的理解。

- 知道其优缺点及适用场景。

「**回答**」

- **CMS（Concurrent Mark-Sweep）**：一种低停顿的垃圾回收器，采用**标记-清除**算法。CMS回收分为初始标记、并发标记、重新标记和并发清除四个阶段。优点是停顿时间短，适用于对延迟敏感的应用。缺点是并发清理阶段可能导致`Concurrent Mode Failure`，需要Full GC。
- **G1（Garbage-First）**：一种面向大内存低延迟应用的垃圾回收器，使用区域（Region）划分堆内存，通过并行和并发回收，分代式管理内存。G1在后台维护一个优先列表，根据回收成本和收益优先回收区域。优点是能更好地控制停顿时间，适用于大内存应用。缺点是配置较复杂，调优成本较高。

### 9. 看过什么源码？讲一讲SpringBoot自动配置原理？

「**考察要点**」

- 对源码阅读的能力和理解深度。

- 能否清晰解释复杂框架的实现原理。

「**回答**」

我阅读过Spring Boot的源码，其中对自动配置（Auto-Configuration）原理印象深刻。Spring Boot通过`@EnableAutoConfiguration`注解实现自动配置。其底层原理是利用`SpringFactoriesLoader`加载`META-INF/spring.factories`中的配置文件，动态注入相应的配置类。通过条件注解（如`@ConditionalOnClass`、`@ConditionalOnMissingBean`）判断是否需要注入某个Bean，从而实现按需配置，减少手动配置工作量。

### 10. 垂直分库，有没有跨数据库查询？

「**考察要点**」

- 对分库分表策略的理解。

- 如何处理跨库查询。

「**回答**」

垂直分库一般会尽量**避免跨数据库查询**，因为跨库查询会带来性能问题和事务管理的复杂性。如果确实需要跨库查询，通常会使用分布式中间件（如**ShardingSphere**）或在应用层进行数据合并。分布式中间件可以提供透明化的跨库查询和事务支持，但会带来一定的性能开销。

### 11. 项目中是如何实现使用Redis作为缓存的？

「**考察要点**」

- 对Redis使用场景的理解。

- 缓存策略和一致性处理。

「**回答**」

在项目中，我们使用Redis作为缓存来提高数据访问的速度。具体实现方式包括：

- 使用Spring Cache抽象层来简化缓存的操作，通过注解（如`@Cacheable`、`@CachePut`、`@CacheEvict`）实现缓存逻辑。
- 采用RedisTemplate或StringRedisTemplate进行缓存数据的CRUD操作，灵活控制缓存的存储和失效策略。
- 利用Redis的Pub/Sub机制，实现缓存的变更通知，保持缓存与数据库的数据一致性。
- 配置合理的缓存失效时间和LRU淘汰策略，防止内存溢出。

### 12. 项目并发量如何？

「**考察要点**」

- 对高并发场景的处理能力。

- 应对高并发的优化措施。

「**回答**」

我们项目的并发量在高峰期大约能达到每秒数千请求。为了应对高并发，我们在架构上采取了多种优化措施，包括：

- 使用Nginx进行反向代理和负载均衡，将请求分发到多台应用服务器。
- 利用Redis进行分布式缓存，减轻数据库的压力。
- 通过消息队列（如Kafka、RabbitMQ）实现异步处理，削峰填谷。
- 采用数据库分库分表和读写分离，提升数据库的并发处理能力。

这些优化措施有效地保障了系统在高并发场景下的稳定性和性能。



链接：https://www.nowcoder.com/feed/main/detail/2bdc394c8a7845ff9aa4b168fdd69440
